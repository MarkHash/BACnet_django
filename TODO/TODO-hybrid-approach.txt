# TODO: Hybrid Docker-Windows Approach for BACnet Discovery

## Background & Problem Statement

### Issue Identified
Docker Desktop on Windows cannot provide access to the Windows host network (192.168.1.x) for BACnet device discovery. The fundamental constraint is that Docker Desktop runs in a Linux VM (WSL2/Hyper-V) which isolates containers from the actual Windows network interfaces.

### Testing Results Summary
| Approach | Network IP | Port Binding | Device Discovery | Status |
|----------|------------|--------------|------------------|---------|
| Port Mapping | 172.18.0.5 | ‚úÖ Success | Docker network only | Working |
| Host Mode | 192.168.65.3 | ‚úÖ Success | Docker VM network | Working |
| Specific IP + connect() | 192.168.1.5 | ‚ùå Failed | N/A | Error |
| Specific IP + lite() | 192.168.1.5 | ‚ùå Failed | N/A | Error |
| Bridge Auto-detect | 172.18.0.5 | ‚úÖ Success | Docker network only | Working |

### Root Cause
- Docker Desktop uses lightweight Linux VM for container execution
- BACnet discovery requires UDP broadcast packets to Windows host network
- Docker networking cannot properly handle broadcast packets between container and Windows host
- This is a fundamental Docker Desktop networking limitation, not an implementation issue

## Proposed Solution: Hybrid Architecture

### Architecture Overview
```
Windows Host:
‚îú‚îÄ‚îÄ Docker Services (containerized)
‚îÇ   ‚îú‚îÄ‚îÄ PostgreSQL database (port 5432)
‚îÇ   ‚îú‚îÄ‚îÄ Redis message broker (port 6379)
‚îÇ   ‚îú‚îÄ‚îÄ Web interface (Django on port 8000)
‚îÇ   ‚îî‚îÄ‚îÄ General Celery worker (non-BACnet tasks)
‚îî‚îÄ‚îÄ Native BACnet Worker (Windows process)
    ‚îî‚îÄ‚îÄ Connects to Docker services via localhost
    ‚îî‚îÄ‚îÄ Has full Windows network access (192.168.1.x)
```

### Benefits
‚úÖ **Simple**: No complex networking configuration required
‚úÖ **Reliable**: Native Windows network access guaranteed
‚úÖ **Maintainable**: Clear separation of containerized vs native components
‚úÖ **Professional**: Industry-standard BACnet deployment pattern
‚úÖ **Debuggable**: Easy to troubleshoot Windows networking issues
‚úÖ **Scalable**: Docker services remain containerized and portable

### Complexity Assessment
**Level**: Medium-Low ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ
**Estimated Time**: 5 hours total (2-3 dev + 1-2 testing + 1 docs)

## Implementation Plan

### Phase 1: Docker Services Configuration (45 minutes)

#### Step 1.1: Update Docker Compose (15 min)
```yaml
# docker-compose.yml - Remove bacnet-worker service entirely
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"  # ‚úÖ Expose for Windows worker access
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"  # ‚úÖ Expose for Windows worker access

  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=redis://redis:6379
    env_file:
      - .env

  celery:
    build: .
    # ‚úÖ Exclude bacnet queue - only process general tasks
    command: celery -A bacnet_project worker --loglevel=info --exclude-queues=bacnet
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=redis://redis:6379
    env_file:
      - .env

  beat:
    build: .
    command: celery -A bacnet_project beat --loglevel=info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=redis://redis:6379
    env_file:
      - .env

volumes:
  postgres_data:

# ‚ùå REMOVED: bacnet-worker service (will run natively on Windows)
```

#### Step 1.2: Update Task Routing Configuration (15 min)
```python
# bacnet_project/settings.py
# Add/update Celery task routing
CELERY_TASK_ROUTES = {
    # BACnet tasks ‚Üí 'bacnet' queue ‚Üí Windows worker
    'discovery.tasks.discover_devices': {'queue': 'bacnet'},
    'discovery.tasks.read_device_points': {'queue': 'bacnet'},
    'discovery.tasks.discover_device_points': {'queue': 'bacnet'},
    'discovery.tasks.read_point_value': {'queue': 'bacnet'},

    # General tasks ‚Üí 'default' queue ‚Üí Docker worker
    'discovery.tasks.calculate_hourly_stats': {'queue': 'default'},
    'discovery.tasks.calculate_daily_stats': {'queue': 'default'},
}

# Ensure queues are defined
CELERY_TASK_DEFAULT_QUEUE = 'default'
CELERY_TASK_CREATE_MISSING_QUEUES = True
```

#### Step 1.3: Update Environment Variables (15 min)
```bash
# .env - Update for hybrid deployment
DB_NAME=bacnet_django
DB_USER=bacnet_user
DB_PASSWORD=your_secure_password
DB_HOST=localhost  # ‚úÖ Accessible from both Docker and Windows
DB_PORT=5432
SECRET_KEY=your-secret-key-here
DEBUG=True

# Redis URLs for different contexts
REDIS_URL=redis://localhost:6379  # For Windows worker
REDIS_DOCKER_URL=redis://redis:6379  # For Docker services

# Database URLs for different contexts
DATABASE_URL=postgresql://bacnet_user:your_secure_password@localhost:5432/bacnet_django  # Windows
DATABASE_DOCKER_URL=postgresql://bacnet_user:your_secure_password@db:5432/bacnet_django  # Docker
```

### Phase 2: Windows BACnet Worker Setup (1.5 hours)

#### Step 2.1: Create Windows Settings Configuration (30 min)
```python
# bacnet_project/windows_settings.py
"""
Django settings for Windows native BACnet worker
Connects to Docker services via localhost
"""
from .settings import *
import os

# Override database connection for Windows worker
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': 'localhost',  # ‚úÖ Connect to Docker-exposed port
        'PORT': '5432',
    }
}

# Override Celery configuration for Windows worker
CELERY_BROKER_URL = 'redis://localhost:6379'
CELERY_RESULT_BACKEND = 'redis://localhost:6379'

# Windows-specific logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '[WINDOWS-WORKER] {levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'windows_bacnet_worker.log',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
        },
        'discovery': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
        },
        'celery': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
        },
    },
}

# Windows BACnet worker identification
WORKER_TYPE = 'WINDOWS_BACNET'
```

#### Step 2.2: Create Windows BACnet Worker Script (45 min)
```python
# bacnet_worker_windows.py
"""
Windows Native BACnet Worker
Handles BACnet discovery tasks with full Windows network access
"""
import os
import sys
import logging
from pathlib import Path

# Add project directory to Python path
project_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(project_dir))

# Configure Django settings for Windows worker
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'bacnet_project.windows_settings')

# Initialize Django
import django
django.setup()

# Import after Django setup
from celery import Celery
from bacnet_project import windows_settings

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[WINDOWS-WORKER] %(levelname)s %(asctime)s %(name)s: %(message)s'
)
logger = logging.getLogger(__name__)

# Create Celery app for Windows worker
app = Celery('bacnet_worker_windows')
app.config_from_object(windows_settings)

def main():
    """Start Windows BACnet worker"""
    logger.info("ü™ü Starting Windows BACnet Worker")
    logger.info("üì° Will handle BACnet discovery tasks with Windows network access")
    logger.info("üîó Connecting to Docker services via localhost")

    try:
        # Test database connection
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
            logger.info("‚úÖ Database connection successful")

        # Test Redis connection
        from django.core.cache import cache
        cache.set('test_key', 'test_value', 1)
        logger.info("‚úÖ Redis connection successful")

        # Start worker - only process bacnet queue
        logger.info("üöÄ Starting Celery worker for 'bacnet' queue...")
        app.worker_main([
            'worker',
            '--loglevel=info',
            '--queues=bacnet',  # ‚úÖ Only process BACnet tasks
            '--hostname=windows-bacnet-worker@%h',
            '--concurrency=2'  # Limit concurrent BACnet operations
        ])

    except Exception as e:
        logger.error(f"‚ùå Failed to start Windows BACnet worker: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
```

#### Step 2.3: Create Windows Batch Script for Easy Startup (15 min)
```batch
@echo off
REM start_bacnet_worker.bat
REM Easy startup script for Windows BACnet worker

echo.
echo ========================================
echo  BACnet Django - Windows Worker Startup
echo ========================================
echo.

REM Check if virtual environment exists
if not exist "bacnet_env\Scripts\activate.bat" (
    echo ‚ùå Virtual environment not found!
    echo Please run setup_windows_env.bat first
    pause
    exit /b 1
)

REM Activate virtual environment
echo üêç Activating Python virtual environment...
call bacnet_env\Scripts\activate.bat

REM Check if Docker services are running
echo üê≥ Checking Docker services...
docker ps --filter "name=bacnet_django" --format "table {{.Names}}\t{{.Status}}" | findstr "Up"
if %errorlevel% neq 0 (
    echo ‚ùå Docker services not running!
    echo Please start Docker services first: docker-compose up
    pause
    exit /b 1
)

REM Start BACnet worker
echo.
echo üöÄ Starting Windows BACnet Worker...
echo üì° Will handle BACnet discovery with Windows network access
echo ‚èπÔ∏è  Press Ctrl+C to stop
echo.
python bacnet_worker_windows.py

echo.
echo üëã Windows BACnet Worker stopped
pause
```

### Phase 3: Windows Environment Setup (30 minutes)

#### Step 3.1: Create Windows Environment Setup Script (15 min)
```batch
@echo off
REM setup_windows_env.bat
REM One-time setup for Windows BACnet worker environment

echo.
echo ==========================================
echo  BACnet Django - Windows Environment Setup
echo ==========================================
echo.

REM Check Python installation
python --version >nul 2>&1
if %errorlevel% neq 0 (
    echo ‚ùå Python not found! Please install Python 3.12+
    echo Download from: https://www.python.org/downloads/
    pause
    exit /b 1
)

echo ‚úÖ Python found
python --version

REM Create virtual environment
if exist "bacnet_env" (
    echo ‚ö†Ô∏è  Virtual environment already exists
    choice /M "Recreate virtual environment? (will delete existing)"
    if errorlevel 2 goto skip_venv
    rmdir /s /q bacnet_env
)

echo üêç Creating Python virtual environment...
python -m venv bacnet_env
if %errorlevel% neq 0 (
    echo ‚ùå Failed to create virtual environment
    pause
    exit /b 1
)

:skip_venv
REM Activate virtual environment
echo üîÑ Activating virtual environment...
call bacnet_env\Scripts\activate.bat

REM Upgrade pip
echo üì¶ Upgrading pip...
python -m pip install --upgrade pip

REM Install requirements
echo üì¶ Installing Python packages...
pip install -r requirements.txt
if %errorlevel% neq 0 (
    echo ‚ùå Failed to install requirements
    pause
    exit /b 1
)

REM Test Django setup
echo üß™ Testing Django configuration...
set DJANGO_SETTINGS_MODULE=bacnet_project.windows_settings
python -c "import django; django.setup(); print('‚úÖ Django setup successful')"
if %errorlevel% neq 0 (
    echo ‚ùå Django configuration test failed
    pause
    exit /b 1
)

echo.
echo ‚úÖ Windows environment setup complete!
echo.
echo Next steps:
echo 1. Start Docker services: docker-compose up
echo 2. Start BACnet worker: start_bacnet_worker.bat
echo.
pause
```

#### Step 3.2: Update Requirements for Windows (15 min)
```txt
# requirements.txt - Ensure Windows compatibility
# Add Windows-specific packages if needed
pywin32; sys_platform == "win32"  # Windows services support
wmi; sys_platform == "win32"      # Windows Management Interface

# Existing packages...
asgiref==3.9.1
bacpypes==0.19.0
# ... rest of requirements
```

### Phase 4: Testing & Validation (1-2 hours)

#### Step 4.1: Unit Testing (30 min)
```python
# tests/test_hybrid_deployment.py
import pytest
from django.test import TestCase
from unittest.mock import patch, Mock

class TestHybridDeployment(TestCase):

    def test_task_routing_configuration(self):
        """Test that BACnet tasks are routed to bacnet queue"""
        from bacnet_project.settings import CELERY_TASK_ROUTES

        bacnet_tasks = [
            'discovery.tasks.discover_devices',
            'discovery.tasks.read_device_points',
            'discovery.tasks.discover_device_points',
            'discovery.tasks.read_point_value'
        ]

        for task in bacnet_tasks:
            self.assertEqual(
                CELERY_TASK_ROUTES[task]['queue'],
                'bacnet',
                f"Task {task} should be routed to bacnet queue"
            )

    def test_windows_database_connection(self):
        """Test database connection from Windows settings"""
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            self.assertEqual(result[0], 1)

    @patch('discovery.services.BACnetService._connect')
    def test_bacnet_worker_network_access(self, mock_connect):
        """Test that BACnet worker can access network"""
        mock_connect.return_value = True

        from discovery.services import BACnetService
        service = BACnetService()

        # Should be able to connect without network errors
        self.assertTrue(service._connect())
```

#### Step 4.2: Integration Testing (45 min)
```python
# tests/test_hybrid_integration.py
import pytest
from django.test import TestCase
from unittest.mock import patch
from celery import current_app

class TestHybridIntegration(TestCase):

    def setUp(self):
        """Setup test environment"""
        # Ensure test database is used
        from django.db import connection
        self.connection = connection

    def test_device_discovery_task_flow(self):
        """Test complete device discovery flow in hybrid setup"""
        from discovery.tasks import discover_devices
        from discovery.models import BACnetDevice

        # Clear existing devices
        BACnetDevice.objects.all().delete()

        # Mock BACnet discovery to return test device
        with patch('discovery.services.BACnetService.discover_devices') as mock_discover:
            mock_discover.return_value = [
                {
                    'device_id': 12345,
                    'address': '192.168.1.100',
                    'name': 'Test BACnet Device',
                    'vendor': 'Test Vendor'
                }
            ]

            # Execute task
            result = discover_devices.delay()

            # Verify task completed
            self.assertTrue(result.successful())

            # Verify device was created in database
            device = BACnetDevice.objects.get(device_id=12345)
            self.assertEqual(device.address, '192.168.1.100')

    def test_web_interface_task_dispatch(self):
        """Test that web interface properly dispatches tasks to queues"""
        from django.test import Client
        from unittest.mock import patch

        client = Client()

        with patch('discovery.tasks.discover_devices.delay') as mock_task:
            # Simulate web interface device discovery request
            response = client.post('/api/start-discovery/')

            # Verify task was dispatched
            mock_task.assert_called_once()
            self.assertEqual(response.status_code, 200)
```

#### Step 4.3: End-to-End Testing Checklist (15 min)
```
Manual Testing Checklist:

‚ñ° Windows Environment Setup
  ‚ñ° Virtual environment created successfully
  ‚ñ° All packages installed without errors
  ‚ñ° Django configuration test passes

‚ñ° Docker Services
  ‚ñ° All 5 services start (db, redis, web, celery, beat)
  ‚ñ° PostgreSQL accessible on localhost:5432
  ‚ñ° Redis accessible on localhost:6379
  ‚ñ° Web interface loads at localhost:8000

‚ñ° Windows BACnet Worker
  ‚ñ° Worker starts without errors
  ‚ñ° Connects to database successfully
  ‚ñ° Connects to Redis successfully
  ‚ñ° Shows "bacnet" queue in logs
  ‚ñ° Network detection shows Windows IP (192.168.1.x)

‚ñ° Task Routing
  ‚ñ° Web interface device discovery triggers task
  ‚ñ° Task appears in Windows worker logs (not Docker worker)
  ‚ñ° BACnet discovery scans Windows network (192.168.1.x)
  ‚ñ° Results saved to database and visible in web interface

‚ñ° Error Handling
  ‚ñ° Windows worker handles BACnet errors gracefully
  ‚ñ° Docker services continue if Windows worker stops
  ‚ñ° Web interface shows appropriate error messages
```

### Phase 5: Documentation & Deployment (1 hour)

#### Step 5.1: Update README with Hybrid Deployment Instructions (30 min)
```markdown
# BACnet Django - Hybrid Deployment Guide

## Architecture Overview

This application uses a hybrid deployment approach to overcome Docker Desktop networking limitations on Windows:

- **Docker Services**: Database, Redis, Web Interface, General Tasks
- **Windows Native**: BACnet Worker (for real network access)

## Prerequisites

### Windows Requirements
- Windows 10/11 with WSL2 or Windows Server
- Python 3.12+
- Docker Desktop with WSL2 backend

### Network Requirements
- BACnet devices on local network (192.168.1.x or similar)
- Windows firewall configured to allow BACnet traffic (UDP port 47808)

## Quick Start

### 1. Initial Setup (One-time)
```cmd
# Clone repository
git clone <repository-url>
cd BACnet_django

# Setup Windows environment
setup_windows_env.bat

# Start Docker services
docker-compose up -d
```

### 2. Daily Operation
```cmd
# Start BACnet worker (Windows)
start_bacnet_worker.bat

# Access web interface
# Open browser: http://localhost:8000
```

### 3. Device Discovery
1. Open web interface at http://localhost:8000
2. Click "Start Discovery" - tasks will be processed by Windows worker
3. Devices on your network (192.168.1.x) will be discovered
4. View results in the web interface

## Troubleshooting

### Windows Worker Issues
- Check `windows_bacnet_worker.log` for errors
- Verify Docker services are running: `docker ps`
- Test network connectivity to BACnet devices

### Docker Services Issues
- Restart services: `docker-compose restart`
- Check logs: `docker-compose logs`
- Verify port availability: `netstat -an | findstr "5432\|6379\|8000"`

## Architecture Benefits
‚úÖ Real Windows network access for BACnet discovery
‚úÖ Containerized scalable services
‚úÖ Professional deployment pattern
‚úÖ Easy development and testing
```

#### Step 5.2: Create Deployment Checklist (30 min)
```markdown
# Hybrid Deployment Checklist

## Pre-Deployment
- [ ] Windows Python 3.12+ installed
- [ ] Docker Desktop installed with WSL2 backend
- [ ] Git repository cloned
- [ ] Environment variables configured (.env file)

## Setup Process
- [ ] Run `setup_windows_env.bat` successfully
- [ ] Virtual environment created and activated
- [ ] All Python packages installed
- [ ] Django configuration test passes
- [ ] Docker services start successfully
- [ ] PostgreSQL accessible on localhost:5432
- [ ] Redis accessible on localhost:6379

## Testing
- [ ] Windows BACnet worker starts without errors
- [ ] Worker connects to database and Redis
- [ ] Web interface loads at localhost:8000
- [ ] Device discovery task routes to Windows worker
- [ ] BACnet discovery scans Windows network
- [ ] Results appear in web interface
- [ ] Worker handles errors gracefully

## Production Considerations
- [ ] Windows service installation (optional)
- [ ] Firewall rules configured for BACnet
- [ ] Log rotation configured
- [ ] Monitoring setup for both Docker and Windows processes
- [ ] Backup procedures for database
- [ ] Network security review completed

## Maintenance
- [ ] Regular log review process
- [ ] Update procedure documented
- [ ] Rollback plan prepared
- [ ] Support contact information available
```

## Success Criteria

### Technical Success
- ‚úÖ BACnet device discovery works with real Windows network access
- ‚úÖ All existing functionality preserved (web interface, database, APIs)
- ‚úÖ Clear separation between containerized and native components
- ‚úÖ Reliable task routing between Docker and Windows workers
- ‚úÖ Comprehensive error handling and logging

### Business Success
- ‚úÖ Office testing with real BACnet devices successful
- ‚úÖ Performance meets or exceeds current Docker-only approach
- ‚úÖ Deployment complexity manageable for IT teams
- ‚úÖ Professional architecture suitable for production
- ‚úÖ Clear documentation for maintenance and troubleshooting

### Development Success
- ‚úÖ Hybrid approach documented as industry best practice
- ‚úÖ Technical challenges overcome with professional solutions
- ‚úÖ Architecture demonstrates understanding of production constraints
- ‚úÖ Implementation showcases advanced deployment patterns
- ‚úÖ Solution provides foundation for future BACnet projects

## Next Steps After Implementation

### Immediate (Week 1)
1. Implement Phase 1: Docker services configuration
2. Implement Phase 2: Windows BACnet worker setup
3. Test basic functionality with office BACnet devices
4. Document any Windows-specific networking discoveries

### Short-term (Week 2-3)
1. Implement comprehensive testing suite
2. Create production deployment documentation
3. Optimize Windows worker performance
4. Add monitoring and alerting capabilities

### Long-term (Month 2+)
1. Consider Windows service installation for production
2. Evaluate cross-platform compatibility (Linux host networking)
3. Explore advanced BACnet features (write operations, scheduling)
4. Integrate with building management systems

## Risk Mitigation

### Technical Risks
- **Windows dependency**: Document Linux alternative using host networking
- **Two-process complexity**: Create automated startup scripts and monitoring
- **Network configuration**: Provide detailed firewall and network setup guides

### Operational Risks
- **Deployment complexity**: Comprehensive documentation and testing
- **Support requirements**: Clear escalation procedures and troubleshooting guides
- **Performance concerns**: Monitoring and optimization recommendations

This hybrid approach represents a **professional solution** to a real-world constraint, demonstrating advanced understanding of containerized deployment patterns and building automation requirements.